/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.jdimension.jlawyer.client.editors.files;

import com.jdimension.jlawyer.client.editors.EditorsRegistry;
import com.jdimension.jlawyer.client.processing.ProgressIndicator;
import com.jdimension.jlawyer.client.processing.ProgressableAction;
import com.jdimension.jlawyer.client.settings.ClientSettings;
import com.jdimension.jlawyer.client.settings.UserSettings;
import com.jdimension.jlawyer.client.utils.DesktopUtils;
import com.jdimension.jlawyer.client.utils.ThreadUtils;
import com.jdimension.jlawyer.persistence.ArchiveFileBean;
import com.jdimension.jlawyer.pojo.DataBucket;
import com.jdimension.jlawyer.services.ArchiveFileServiceRemote;
import com.jdimension.jlawyer.services.DataBucketLoaderRemote;
import com.jdimension.jlawyer.services.JLawyerServiceLocator;
import java.awt.Component;
import java.awt.FlowLayout;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import org.apache.log4j.Logger;

/**
 *
 * @author max
 */
public class CaseExportDialog extends javax.swing.JDialog {

    private static final Logger log = Logger.getLogger(CaseExportDialog.class.getName());
    private List<CaseSelectionPanel> caseSelectionPanels = new ArrayList<>();

    /**
     * Creates new form CaseExportDialog
     *
     * @param parent
     * @param modal
     */
    public CaseExportDialog(javax.swing.JFrame parent, boolean modal) {
        super(parent, modal);
        initComponents();
        loadCases();
        pack();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        hintLabel = new javax.swing.JLabel();
        scrollPane = new javax.swing.JScrollPane();
        caseListPanel = new javax.swing.JPanel();
        selectAllButton = new javax.swing.JButton();
        deselectAllButton = new javax.swing.JButton();
        cancelButton = new javax.swing.JButton();
        exportButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Akten für den Export auswählen");
        setMinimumSize(new java.awt.Dimension(700, 520));

        hintLabel.setFont(hintLabel.getFont());
        hintLabel.setText("Export von Akten, für die Synchronisation mit der App aktiviert sind");
        hintLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));

        scrollPane.setMinimumSize(new java.awt.Dimension(400, 320));
        scrollPane.setPreferredSize(new java.awt.Dimension(400, 320));

        caseListPanel.setLayout(new javax.swing.BoxLayout(caseListPanel, javax.swing.BoxLayout.Y_AXIS));
        scrollPane.setViewportView(caseListPanel);

        selectAllButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons16/baseline_select_all_black_48dp.png"))); // NOI18N
        selectAllButton.setToolTipText("Alle auswählen");
        selectAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectAllButtonActionPerformed(evt);
            }
        });

        deselectAllButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons16/baseline_select_none_black_48dp.png"))); // NOI18N
        deselectAllButton.setToolTipText("Keine auswählen");
        deselectAllButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deselectAllButtonActionPerformed(evt);
            }
        });

        cancelButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/cancel.png"))); // NOI18N
        cancelButton.setText("Abbrechen");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        exportButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/agt_action_success.png"))); // NOI18N
        exportButton.setText("Export");
        exportButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(cancelButton)
                        .addGap(5, 5, 5)
                        .addComponent(exportButton))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(selectAllButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(deselectAllButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(hintLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 828, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(selectAllButton)
                            .addComponent(deselectAllButton)))
                    .addComponent(hintLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 400, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(cancelButton)
                    .addComponent(exportButton))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void selectAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectAllButtonActionPerformed
        setAllSelected(true);
    }//GEN-LAST:event_selectAllButtonActionPerformed

    private void deselectAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deselectAllButtonActionPerformed
        setAllSelected(false);
    }//GEN-LAST:event_deselectAllButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        dispose();
    }//GEN-LAST:event_cancelButtonActionPerformed

    private void exportButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportButtonActionPerformed
        onExport();
    }//GEN-LAST:event_exportButtonActionPerformed

    private void loadCases() {
        try {
            ClientSettings settings = ClientSettings.getInstance();
            JLawyerServiceLocator locator = JLawyerServiceLocator.getInstance(settings.getLookupProperties());
            ArchiveFileServiceRemote fileService = locator.lookupArchiveFileServiceRemote();
            String principalId = UserSettings.getInstance().getCurrentUser().getPrincipalId();
            List<String> caseIds = fileService.getCaseIdsSyncedForUser(principalId);

            List<ArchiveFileBean> cases = new ArrayList<>();
            for (String caseId : caseIds) {
                ArchiveFileBean caseBean = fileService.getArchiveFile(caseId);
                if (caseBean != null) {
                    cases.add(caseBean);
                }
            }

            cases.sort(Comparator.comparing(ArchiveFileBean::getFileNumber,
                    Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER)));

            for (ArchiveFileBean caseBean : cases) {
                CaseSelectionPanel panel = new CaseSelectionPanel(caseBean);
                caseSelectionPanels.add(panel);
                caseListPanel.add(panel);
            }
            caseListPanel.revalidate();
            caseListPanel.repaint();
        } catch (Exception e) {
            log.error("Fehler beim Laden der synchronisierten Akten", e);
            JOptionPane.showMessageDialog(this, "Fehler beim Laden der synchronisierten Akten: " + e.getMessage(), "Fehler", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void onExport() {
        List<ArchiveFileBean> selectedCases = new ArrayList<>();
        for (CaseSelectionPanel panel : caseSelectionPanels) {
            if (panel.isSelected()) {
                selectedCases.add(panel.getCaseBean());
            }
        }

        if (selectedCases.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Bitte wählen Sie mindestens eine Akte für den Export aus.", "Keine Akten ausgewählt", JOptionPane.WARNING_MESSAGE);
            return;
        }

        JFileChooser chooser = new JFileChooser();
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        chooser.setDialogTitle("Zielordner für den Export auswählen");
        int result = chooser.showSaveDialog(this);

        if (result == JFileChooser.APPROVE_OPTION) {
            File destinationDir = chooser.getSelectedFile();
            dispose();

            ProgressIndicator indicator = new ProgressIndicator(EditorsRegistry.getInstance().getMainWindow(), true);
            BatchExportAction action = new BatchExportAction(indicator, this, destinationDir, selectedCases);
            action.start();
        }
    }

    private void setAllSelected(boolean selected) {
        for (CaseSelectionPanel panel : caseSelectionPanels) {
            panel.setSelected(selected);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cancelButton;
    private javax.swing.JPanel caseListPanel;
    private javax.swing.JButton deselectAllButton;
    private javax.swing.JButton exportButton;
    private javax.swing.JLabel hintLabel;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JButton selectAllButton;
    // End of variables declaration//GEN-END:variables

    private class CaseSelectionPanel extends JPanel {

        private JCheckBox checkBox;
        private ArchiveFileBean caseBean;

        public CaseSelectionPanel(ArchiveFileBean caseBean) {
            this.caseBean = caseBean;
            setLayout(new FlowLayout(FlowLayout.LEFT));
            checkBox = new JCheckBox();
            checkBox.setSelected(true);
            add(checkBox);
            add(new JLabel(caseBean.getFileNumber() + " - " + caseBean.getName()));
        }

        public boolean isSelected() {
            return checkBox.isSelected();
        }

        public void setSelected(boolean selected) {
            checkBox.setSelected(selected);
        }

        public ArchiveFileBean getCaseBean() {
            return caseBean;
        }
    }

    private class BatchExportAction extends ProgressableAction {

        private final Component owner;
        private final File baseDir;
        private final List<ArchiveFileBean> cases;

        public BatchExportAction(ProgressIndicator indicator, Component owner, File baseDir, List<ArchiveFileBean> cases) {
            super(indicator, false);
            this.owner = owner;
            this.baseDir = baseDir;
            this.cases = cases;
        }

        @Override
        public int getMin() {
            return 0;
        }

        @Override
        public int getMax() {
            return cases.size();
        }

        @Override
        public boolean execute() throws Exception {

            List<String> caseIds=new ArrayList<>();
            for(ArchiveFileBean afb: this.cases) {
                caseIds.add(afb.getId());
            }

            try {
                ClientSettings settings = ClientSettings.getInstance();
                JLawyerServiceLocator locator = JLawyerServiceLocator.getInstance(settings.getLookupProperties());
                ArchiveFileServiceRemote fileService = locator.lookupArchiveFileServiceRemote();
                this.progress("Export wird erstellt...", 2);
                DataBucket bucket = fileService.loadHtmlCaseExport(caseIds);
                int max = bucket.getTotalNumberOfBuckets() + 2;
                try (FileOutputStream output = new FileOutputStream(baseDir.getPath() + File.separator + bucket.getFileName(), true)) {
                    output.write(bucket.getPayload());
                }
                DataBucketLoaderRemote bucketLoader = locator.lookupDataBucketLoaderRemote();
                while (bucket.hasNext()) {
                    if (this.isCancelled()) {
                        return true;
                    }
                    double percentage = bucket.getPercentage();
                    this.progress("Lade Export vom Server... " + (int) percentage + "%", max);
                    bucket.resetPayload();
                    bucket = bucketLoader.nextBucket(bucket);
                    try (FileOutputStream output = new FileOutputStream(baseDir.getPath() + File.separator + bucket.getFileName(), true)) {
                        output.write(bucket.getPayload());
                    }
                }

                //get the zip file content
                FileInputStream bucketInStream = new FileInputStream(baseDir.getPath() + File.separator + bucket.getFileName());
                ZipInputStream zis
                        = new ZipInputStream(bucketInStream);
                //get the zipped file list entry
                ZipEntry ze = zis.getNextEntry();

                String browserUrl = "file://" + baseDir.getPath() + "/";
                String indexHtml = null;

                while (ze != null) {

                    String fileName = ze.getName();
                    this.progress("Entpacke Datei " + fileName);
                    if (fileName.endsWith("index.html")) {
                        if(indexHtml==null)
                            indexHtml=fileName;
                        if(indexHtml.length()>fileName.length())
                            indexHtml=fileName;
                    }
                    File newFile = new File(baseDir.getPath() + File.separator + fileName);
                    byte[] buffer = new byte[1024];
                    //create all non exists folders
                    //else you will hit FileNotFoundException for compressed folder
                    new File(newFile.getParent()).mkdirs();

                    try (FileOutputStream fos = new FileOutputStream(newFile)) {

                        int len;
                        while ((len = zis.read(buffer)) > 0) {
                            fos.write(buffer, 0, len);
                        }
                    }

                    try {
                        if (ze.getLastModifiedTime() != null) {
                            newFile.setLastModified(ze.getLastModifiedTime().toMillis());
                        } else {
                            log.warn("ZIP entry does not have a last modified timestamp for " + newFile.getName());
                        }
                    } catch (Throwable t) {
                        log.error("Unable to set last modified time", t);
                    }

                    ze = zis.getNextEntry();
                }

                zis.closeEntry();
                zis.close();
                bucketInStream.close();
                String bucketFile = baseDir.getPath() + File.separator + bucket.getFileName();
                if (!(new File(bucketFile).delete())) {
                    log.error("Could not delete data bucket file " + bucketFile);
                }

                DesktopUtils.openBrowserFromDialog(browserUrl + indexHtml, this.indicator);

            } catch (Throwable t) {
                log.error("Could not unzip exported case", t);
                ThreadUtils.showErrorDialog(EditorsRegistry.getInstance().getMainWindow(), "Fehler beim Exportieren der Akte: " + t.getMessage(), com.jdimension.jlawyer.client.utils.DesktopUtils.POPUP_TITLE_ERROR);
                EditorsRegistry.getInstance().clearStatus(true);
                ThreadUtils.setDefaultCursor(this.owner);
            }
            EditorsRegistry.getInstance().clearStatus(true);
            ThreadUtils.setDefaultCursor(this.owner);

            return true;

        }
    }
}
